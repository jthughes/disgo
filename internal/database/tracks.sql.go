// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tracks.sql

package database

import (
	"context"
	"database/sql"
)

const createTrack = `-- name: CreateTrack :one
INSERT INTO tracks (
    id,
	created_at,
    updated_at,
	file_name,
    mime_type,
    meta_album,
	meta_album_artist,
	meta_artist,
	meta_bitrate,
	meta_duration,
	meta_genre,
	meta_has_drm,
	meta_is_variable_bitrate,
	meta_title,
	meta_track,
	meta_year,
	file_location,
	file_source)
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
	?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
) RETURNING id, created_at, updated_at, file_name, mime_type, meta_album, meta_album_artist, meta_artist, meta_bitrate, meta_duration, meta_genre, meta_has_drm, meta_is_variable_bitrate, meta_title, meta_track, meta_year, file_location, file_source
`

type CreateTrackParams struct {
	ID                    string
	CreatedAt             string
	UpdatedAt             string
	FileName              string
	MimeType              string
	MetaAlbum             sql.NullString
	MetaAlbumArtist       sql.NullString
	MetaArtist            sql.NullString
	MetaBitrate           sql.NullInt64
	MetaDuration          sql.NullInt64
	MetaGenre             sql.NullString
	MetaHasDrm            sql.NullInt64
	MetaIsVariableBitrate sql.NullInt64
	MetaTitle             sql.NullString
	MetaTrack             sql.NullInt64
	MetaYear              sql.NullInt64
	FileLocation          string
	FileSource            string
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) (Track, error) {
	row := q.db.QueryRowContext(ctx, createTrack,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.FileName,
		arg.MimeType,
		arg.MetaAlbum,
		arg.MetaAlbumArtist,
		arg.MetaArtist,
		arg.MetaBitrate,
		arg.MetaDuration,
		arg.MetaGenre,
		arg.MetaHasDrm,
		arg.MetaIsVariableBitrate,
		arg.MetaTitle,
		arg.MetaTrack,
		arg.MetaYear,
		arg.FileLocation,
		arg.FileSource,
	)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileName,
		&i.MimeType,
		&i.MetaAlbum,
		&i.MetaAlbumArtist,
		&i.MetaArtist,
		&i.MetaBitrate,
		&i.MetaDuration,
		&i.MetaGenre,
		&i.MetaHasDrm,
		&i.MetaIsVariableBitrate,
		&i.MetaTitle,
		&i.MetaTrack,
		&i.MetaYear,
		&i.FileLocation,
		&i.FileSource,
	)
	return i, err
}

const getAlbumsByName = `-- name: GetAlbumsByName :many
SELECT DISTINCT meta_album FROM tracks
ORDER BY meta_album ASC
`

func (q *Queries) GetAlbumsByName(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumsByName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var meta_album sql.NullString
		if err := rows.Scan(&meta_album); err != nil {
			return nil, err
		}
		items = append(items, meta_album)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTracksByAlbum = `-- name: GetTracksByAlbum :many
SELECT id, created_at, updated_at, file_name, mime_type, meta_album, meta_album_artist, meta_artist, meta_bitrate, meta_duration, meta_genre, meta_has_drm, meta_is_variable_bitrate, meta_title, meta_track, meta_year, file_location, file_source FROM tracks
WHERE tracks.meta_album = ?
ORDER BY meta_track ASC
`

func (q *Queries) GetTracksByAlbum(ctx context.Context, metaAlbum sql.NullString) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, getTracksByAlbum, metaAlbum)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FileName,
			&i.MimeType,
			&i.MetaAlbum,
			&i.MetaAlbumArtist,
			&i.MetaArtist,
			&i.MetaBitrate,
			&i.MetaDuration,
			&i.MetaGenre,
			&i.MetaHasDrm,
			&i.MetaIsVariableBitrate,
			&i.MetaTitle,
			&i.MetaTrack,
			&i.MetaYear,
			&i.FileLocation,
			&i.FileSource,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
